/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2026 SARL.io, the original authors and main authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.api.core

import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import io.sarl.lang.core.Behavior
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventListener
import io.sarl.lang.core.EventSpace
import io.sarl.lang.core.Scope
import io.sarl.lang.core.Space
import io.sarl.lang.core.SpaceID
import io.sarl.lang.core.annotation.SarlAsynchronousExecution
import io.sarl.lang.core.util.ConcurrentCollection
import io.sarl.lang.core.util.ConcurrentSet
import java.text.MessageFormat
import java.util.UUID
import java.util.concurrent.TimeUnit
import java.util.function.Supplier
import java.util.logging.Logger

/**
 * Provides functions for accessing and managing the external contexts of an agent.
 */	 
capacity ExternalContextAccess {

	/**
	 * Replies all contexts this agent is a member of, including the default context.
	 *
	 * @return the list of the known agent contexts.
	 */	 
	@Pure
	def getAllContexts : ConcurrentCollection<AgentContext>

	/**
	 * Replies the AgentContext for the given ID.
	 * The agent must have joined the context before calling this action or use its parentContextID
	 *
	 * @param contextID the ID of the context to get.
	 * @return the agent context instance.
	 * @throws UnknownContextException if the context specified context is not known by the agent.
	 * @see Agent#getParentID
	 * @see #join
	 */
	@Pure
	def getContext(contextID : UUID): AgentContext

	/**
	 * Replies the AgentContext that is the root of all the contexts.
	 * Usually, the Universe context is managed by the SARL run-time environment.
	 * The agent may be a member of this context, or not.
	 *
	 * @return the context that is at the root of all the contexts.
	 * @since 0.7
	 */
	@Pure
	def getUniverseContext(): AgentContext

    /**
	 * Joins a new parent context (a new super holon).
	 * <p>
	 * The agent will be involved in the context with the ID given by <var>contextID</var>.
	 * The parameter <var>expectedDefaultSpaceID</var> is only used to check if
	 * the caller of this function knows the ID of the default space in the context to
	 * be involved in. Note that the context must already exists, and the default space
	 * inside this context must have the same ID as <var>expectedDefaultSpaceID</var>.
	 * If the given <var>expectedDefaultSpaceID</var> does not match the ID of the
	 * default space in the context <var>contextID</var>, then the access to the context
	 * is forbidden.
	 *
	 * <p>This actions registers the agent in the default Space of the context with the
	 * ID <var>contextID</var>.
	 *
	 * <p>This function replies {@code false} if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive;</li>
	 * <li>the given context identifier does not corresponds to a known context;</li>
	 * <li>the given space identifier is not the one of the context's default space;</li>
	 * <li>the given context identifier corresponds to a context in which the agent is already member.</li>
	 * </ul>
	 *
	 * @param contextID the identifier of the context to join.
	 * @param expectedDefaultSpaceID the known identifier of the default space in the agent context with the given identifier.
	 * @return the joined context. {@code null} if the context cannot be joined.
	 * @fires ContextJoined in its inner Context default space (Behaviors#wake).
	 * @fires MemberJoined in its parent Context default Space
	 * @since 0.12 for the returned context.
	 */
	def join(contextID : UUID, expectedDefaultSpaceID : UUID) : AgentContext fires ContextJoined, MemberJoined

	/**
	 * Leaves the parent's context.
	 *
	 * <p>Because an agent must be always into a context, this function fails (and replies {@code false}) when
	 * the context to be leaved is the current default context of the agent, and there is no other context or
	 * more than 1 other context that could be elected as the new default context.
	 *
	 * <p>This function replies {@code false} if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive;</li>
	 * <li>the given context identifier does not corresponds to a known context;</li>
	 * <li>the given context identifier corresponds to a context in which the agent is not member.</li>
	 * <li>the given context identifier corresponds to a known external context, but there is no other
	 * context to be elected as the new default context for the agent.</li>
	 * </ul>
	 *
	 * @param contextID the identifier of the context to leave.
	 * @return {@code true} if the agent has leaved the context. {@code false} if one of the conditions described in
	 *     the function's comment evaluates to true.
	 * @fires ContextLeft in its inner Context default space (Behaviors#wake).
	 * @fires MemberLeft in its parent Context default Space 
	 */
	def leave(contextID : UUID) : boolean fires ContextLeft, MemberLeft

	/** Replies if the given event was emitted in the given space.
	 *
	 * @param event the event to test.
	 * @param space the space in which the event may be.
	 * @return {@code true} if the given event was emitted in the
	 *     given space. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, ^space : Space) : boolean

	/** Replies if the given event was emitted in the space with
	 * the given identifier..
	 *
	 * @param event the event to test.
	 * @param spaceID the identifier of the space in which the event may be.
	 * @return {@code true} if the given event was emitted in the
	 *     space with the given identifier. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, spaceID : SpaceID) : boolean

	/** Replies if the given event was emitted in the space with
	 * the given identifier..
	 *
	 * @param event the event to test.
	 * @param spaceID the identifier of the space in which the event may be.
	 * @return {@code true} if the given event was emitted in the
	 *     space with the given identifier. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, spaceID : UUID) : boolean

	/**
	 * Emits a given event with the provided scope in the given space.
	 * Equivalent to {@code space.emit(getID,event,scope)}
	 *
	 * @param space the space in which the event should be fired.
	 * @param event the event to emit.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events. If {@code null}, all the agents in the space will receive the event.
	 * @since 0.6
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emit(^space : EventSpace, ^event : Event, scope : Scope<Address> = null)

}

/**
 * Provides functions for accessing and managing the internal contexts of an agent.
 */	 
capacity InnerContextAccess {

	/** Replies the inner context.
	 *
	 * @return the instance of the internal agent context.
	 */
	@Pure
	def getInnerContext : AgentContext
	
	/** Replies the inner context.
	 *
	 * @return the instanceof the internal agent context.
	 * @since 0.12
	 */
	@Pure
	def getInnerDefaultSpace : EventSpace

	/** Replies if the calling agent has other agents
	 * as members of its inner context.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context.
	 *
	 * @return {@code true} if the current agent has other agents as member of its internal context; otherwise {@code false}
	 */
	@Pure
	def hasMemberAgent : boolean
	
	/** Replies the number of agents that are members
	 * of the inner context of the calling agent.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context.
	 *
	 * <p>The replied number includes the current agent. Indeed, the current agent is member of its internal context with the role of super-holon.
	 *
	 * @return the number of members in the internal context of the current agent.
	 */
	@Pure
	def getMemberAgentCount : int

	/**
	 * Replies all the member agents in the inner context.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context. 
	 *
	 * @return the identifiers of the members of the internal context of the current agent.
	 */	 
	@Pure
	def getMemberAgents : ConcurrentSet<UUID>

	/** Replies if the given space is the default space of the inner context.
	 *
	 * @param space the space to test.
	 * @return {@code true} if the given space is the default space of
	 *     the inner context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(^space : Space) : boolean

	/** Replies if the given identifier is the identifier of the
	 * default space of the inner context.
	 *
	 * @param spaceID the identifier to test.
	 * @return {@code true} if the given identifier is the identifier
	 *     of the default space of the inner context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(spaceID : SpaceID) : boolean

	/** Replies if the given identifier is the identifier of the
	 * default space of the inner context.
	 *
	 * @param spaceID the identifier to test.
	 * @return {@code true} if the given identifier is the identifier
	 *     of the default space of the inner context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(spaceID : UUID) : boolean

	/** Replies if the given event was emitted in the default space
	 * of the inner context.
	 *
	 * @param event the event to test.
	 * @return {@code true} if the given event was emitted
	 *     in the default space of the inner context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInInnerDefaultSpace(^event : Event) : boolean

}

/**
 * Agent behaviors management.
 */
capacity Behaviors {

	/** Replies {@code true} if at least a behavior is registered.
	 *
	 * <p>A registered behavior is not necessary running. It may wait for events.
	 *
	 * @return {@code true} if a behavior is registered; otherwise {@code false}.
	 * @since 0.5
	 */
	def hasRegisteredBehavior : boolean

	/** Replies the registered behaviors.
	 *
	 * <p>A registered behavior is not necessary running. It may wait for events.
	 *
	 * @return the unmodifiable collection of the registered behavior.
	 * @since 0.5
	 */
	def getRegisteredBehaviors : ConcurrentCollection<Behavior>

	/**
	 * Register a Behavior for the owner agent.
	 * The new Behavior will react to all declared events received by the agent.
	 *
	 * <p>If the filter is provided, it will be used for determining if the given behavior accepts a specific event.
	 * If the filter function replies {@code true} for a specific event as argument, the event is fired in the
	 * behavior context. If the filter function replies {@code false}, the event is not fired in the behavior context. 
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param attitude the behavior to add to the agent.
	 * @param filter the filter that enables to indicates if an event is accepted by a behavior.
	 * @param initializationParameters the set of parameters to pass to the behavior within the {@code Initialize} event.
	 * @return the given behavior.
	 * @since 0.5 for the {@code filter} parameter.
	 */
	def registerBehavior(attitude : Behavior, filter : (Event) => boolean = null, initializationParameters : Object*) : Behavior
	
	/**
	 * Unregisters a behavior for the owner agent.
	 *
	 * @param attitude the behavior to remove to the agent.
	 * @return the given behavior.
	 */
	def unregisterBehavior(attitude : Behavior) : Behavior
	
	/**
	 * Wake the agent's behaviors reacting to the Event evt.
	 *
	 * <p>Note that the scope parameter could be used only for filtering the agents (the current receiving agent)
	 * in order to determine the ones that will receive the event.
	 * The behaviors of the current agent (registered with
	 * {@link #registerBehavior(Behavior, Function1, Object[])}
	 * will always
	 * receive the event if the current agent is not discarded. Because the behaviors have no associated address,
	 * they cannot be filtered individually.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(^event : Event, scope : Scope<Address> = null)
	
	/**
	 * Wake a specific agent's behavior reacting to the Event evt.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param behavior the agent's behavior to wake up.
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(^behavior : Behavior, ^event : Event)

	/**
	 * Wake a set of specific agent's behaviors reacting to the Event evt.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param behaviors the agent's behaviors to wake up.
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(behaviors : Iterable<Behavior>, ^event : Event)

	/**
	 * Replies the interface to dispatch an event to agent's Behaviors.
	 *
	 * @return the event listener.
	 */
	@Pure
	def asEventListener : EventListener

}

/**
 * Lifecycle related actions.
 */
capacity Lifecycle {

	/**
	 * Spawns a new Agent inside the default context of this agent.
	 * This action must automatically register the newly created agent
	 * within the default space of the context.
	 *
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentType the type of the agent to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agent.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(agentType : Class<? extends Agent>, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a group of agents inside the default context of this agent.
	 * This action must automatically register the newly created agents
	 * within the default space of the context.
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agents
	 * are initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param nbAgents the number of agents to spawn.
	 * @param agentType the type of the agents to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agents. All the agents
	 *     will receive the same initialization parameters.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(nbAgents : int, agentType : Class<? extends Agent>, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param context the context in which the agent must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContext(agentClass : Class <? extends Agent>, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure
	
	/**
	 * Spawns a group of agents in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agents
	 * are initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param nbAgents the number of agents to spawn.
	 * @param agentClass the type of the agents to spawn.
	 * @param context the context in which the agents must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agents. All the agents
	 *     will receive the same initialization parameters.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContext(nbAgents : int, agentClass : Class <? extends Agent>, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the given context.
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param agentID the identifier of the spawned agent.
	 * @param context the context in which the agent must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContextWithID(agentClass : Class <? extends Agent>, agentID : UUID, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param agentID the identifier of the spawned agent.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnWithID(agentClass : Class <? extends Agent>, agentID : UUID, params : Object*) fires AgentSpawned, AgentSpawnFailure

    /**
	 * Kills this agent. 
	 *
	 * <p>This action must automatically unregister this agent from the default context 
	 * and therefore all its spaces including the DefaultSpace.
	 * If this is a composable agent, it must not have any members before calling this action. 
	 * Otherwise a RuntimeException will be thrown.  
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param terminationCause indicates the cause of the termination of the agent.
	 *      If this argument is {@code null}, the agent terminates without specific cause.
	 * @fires AgentKilled in DefaultSpace of all Contexts to which this agent belongs
	 * @fires Destroy inside the agent
	 * @fires AgentKillFailure inside the agent
	 * @since 0.12
	 */
	def killMe(terminationCause : Object = null) fires AgentKilled, Destroy, AgentKillFailure
}


/**
 * Schedules actions in time.
 */
capacity Schedules {

	/**
	 * Replies the names of the active tasks.
	 *
	 * @return the names of the active tasks.
	 * @since 0.5
	 */
	def getActiveTasks : ConcurrentSet<String>
	
	/**
	 * Schedule a given task to be executed after the specified delay.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name {@code it} by default.
	 *
	 * <p>The given delay is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task that will run the given closure. If {@code null}, a new task is created.
	 * @param delay time in milliseconds to delay the procedure execution.
	 * @param procedure the closure to execute.
	 * @return the generated task.
	 */
	def in(task : AgentTask = null, delay : long, procedure : (Agent) => void) : AgentTask

	/**
	 * Create a named task that can be retrieved and schedule later.
	 * If a task with the specified name already exists, this task is returned.
	 *
	 * <p>If this function is invoked from a {@code Behavior}, the created task will be associated
	 * to the behavior instance. It means that the task will be automatically canceled when the behavior
	 * instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param name the name of the task. If {@code null} or empty, a random name will be given to the task.
	 * @return the task instance, or {@code null} if one of the conditions in the function's comment
	 *      evaluates to true.
	 */
	def task(name : String) : AgentTask

	/**
	 * Change the name of the given task.
	 *
	 * <p>This function should not be directly invoked from a regular SARL code.
	 * It is provided for enabling a SRE to change the name of a task.
	 *
	 * @param task the task to change.
	 * @param name the new name of the task.
	 * @since 0.7
	 */
	def setName(task : AgentTask, name : String)

	/**
	 * Attempts to cancel execution of this task.  This attempt will
	 * fail if the task has already completed, has already been canceled,
	 * or could not be canceled for some other reason. If successful,
	 * and this task has not started when {@code cancel} is called,
	 * this task should never run.  If the task has already started,
	 * then the {@code mayInterruptIfRunning} parameter determines
	 * whether the thread executing this task should be interrupted in
	 * an attempt to stop the task.
	 *
	 * @param task the task to cancel.
	 * @param mayInterruptIfRunning {@code true} if the thread executing this
	 *     task should be interrupted; otherwise, in-progress tasks are allowed
	 *     to complete
	 * @return {@code false} if the task could not be canceled,
	 *     typically because it has already completed normally;
	 *     {@code true} otherwise
	 */
	def cancel(task : AgentTask, mayInterruptIfRunning : boolean = true) : boolean

	/**
	 * Replies if the given task was canceled.
	 *
	 * @param task the task.
	 * @return {@code true} if the task was canceled with {@link #cancel(AgentTask,boolean)}
	 *     or {@link #cancel(AgentTask)}; {@code false} otherwise.
	 * @since 0.5
	 */
	def isCanceled(task : AgentTask) : boolean

	/**
	 * Schedule a periodic execution of the given task.
	 *
	 * <p>If the duration of the task is greater to the given period length, then
	 * multiple task's instances will be run in parallel, in opposite to the
	 * {@code atFixedDelay()} function.
	 * For example, consider the following code:
	 * <pre>{@code 
	 * every(500) [ sleep(2000) ]
	 * }</pre>
	 * At a given time, 4 instances (A, B, C, D) of the task may be run in parallel:
	 * <pre>{@code 
	 * t=0   0500   1000   1500   2000   2500   3000   3500   4000   4500
	 *   |    |      |      |      |      |      |      |      |      |
	 *   [-A-----------------------]
	 *        [-B-------------------------]
	 *               [-C-------------------------]
	 *                      [-D-------------------------]
	 *                             [-E-------------------------]
	 *                                    [-F-------------------------]
	 * }</pre>
	 * For executing a task with a fixed delay between the runs, and not at a fixed rate,
	 * you should use the {@code atFixedDelay()} function.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name {@code it} by default.
	 *
	 * <p>The given period is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param period the number of milliseconds between two launches of the given procedure.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 */
	def every(task : AgentTask = null, period : long, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a single-execution task.
	 *
	 * <p>If the duration of the task is greater to the given delay length, then
	 * no multiple task's instance are run in parallel, in opposite to the
	 * {@code every()} function.
	 * For example, consider the following code:
	 * <pre>{@code 
	 * atFixedDelay(500) [ sleep(2000) ]
	 * }</pre>
	 * At a given time, 3 instances (A, B, C) of the task are run in sequence, and
	 * each run is separated by 500 milliseconds:
	 * <pre>{@code 
	 * t=0   0500   1000   1500   2000   2500   3000   3500   4000   4500   5000
	 *   |    |      |      |      |      |      |      |      |      |      |
	 *   [-A-----------------------]
	 *                                    [-B-------------------------]
	 *                                                                       [-C-------------------------]
	 * }</pre>
	 * For executing a task with a fixed rate, and not with a fixed delay between the task runs,
	 * you should use the {@code every()} function.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name {@code it} by default.
	 *
	 * <p>The given delay is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>It is recommended that the SARL run-time environment, which is providing the implementation
	 * of this function to provide an efficient implementation in the case the argument
	 * {@code delay} is equal to zero. Indeed, if the {@code delay} is equal to zero, the task
	 * should be run in an infinite loop until it is canceled, or the owning agent is killed.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param delay the delay in milliseconds.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 * @since 0.5
	 */
	def atFixedDelay(task : AgentTask = null, delay : long, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a single-execution task.
	 *
	 * <p>This function is the easy to use version and efficient implementation of the code
	 * {@code in(0) [statements]}.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name {@code it} by default.
	 *
	 * <p>This function is supposed to execute the given procedure, even if the agent is not alive.
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 * @since 0.5
	 */
	def execute(task : AgentTask = null, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a given task to be executed at the given time.
	 *
	 * <p>If the given time is passed, according to {@link Time} then the task is not executed.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name {@code it} by default.
	 *
	 * <p>The given time is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task that will run the given closure. If {@code null}, a new task is created.
	 * @param time the time in milliseconds at which to start the procedure execution.
	 * @param procedure the closure to execute.
	 * @return the task is given, or a new task if the procedure is schedule, or
	 *     {@code null} if the procedure is not scheduled.
	 * @since 0.9
	 */
	def at(task : AgentTask = null, time : long, procedure : (Agent) => void) : AgentTask

}


/**
 * Gives access to the DefaultContext of the agent and common actions on its default space.
 * Defines a set of commonly accessed action performed on the Default Space 
 * of the Default Context of the agent.
 */
capacity DefaultContextInteractions {

	/**
	 * Returns the Default context fo the agent.
	 *
	 * @return the default context.
	 */
	@Pure
	def getDefaultContext : AgentContext
	
	/**
	 * Returns the Default Space of the Default Context.
	 * Equivalent to {@code defaultContext.defaultSpace}.
	 *
	 * @return the default event space.
	 */
	@Pure
	def getDefaultSpace : EventSpace
	
	/**
	 * Return the Address of the agent in the Default Space of the Default Context.
	 * Equivalent to {@code defaultContext.defaultSpace.getAddress(this.ID)}
	 *
	 * @return the address of the agent in the default space.
	 */
	@Pure
	def getDefaultAddress : Address

	/**
	 * Emits a given event with the provided scope in the DefaultSpace of the DefaultContext.
	 * Equivalent to {@code defaultContext.defaultSpace.emit(e,scope)}
	 *
	 * @param event the event to emit.
	 * @optionalparam scope the definition of the scope that will be used for selected the receivers of the events. If {@code null}, all the agents in the space will receive the event.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emit(^event : Event, scope : Scope<Address> = null)

	/**
	 * Replies the identifier of the default parent.
	 *
	 * <p>The default parent agent has the same identifier as the default context.
	 *
	 * @return the identifier of the default parent of the current agent.
	 * @since 0.12
	 */
	def getDefaultParentID : UUID

	/**
	 * Replies the event scope that corresponds to the default parent.
	 *
	 * @return the identifier of the default parent of the current agent.
	 * @since 0.12
	 */
	def getDefaultParentScope : Scope<Address>

	/**
	 * Emits or forward the given event to the parent agent into the default context of the calling agent.
	 *
	 * @param event the event to emit.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emitToParent(^event : Event)

	/**
	 * Inverse signature of send. Useful to send events using the agent's UUID.
	 *
	 * @param receiver the identifier of the expected receiver.
	 * @param event the event to emit.
	 * @since 0.4
	 * @deprecated since 0.11, see {@link #emit(Event,Scope)} 
	 */
	@Deprecated(since = "0.11", forRemoval = true)
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def willReceive(receiver : UUID, ^event : Event)

	/** Replies if the given space is the default space of the default context.
	 *
	 * @param space the space to test.
	 * @return {@code true} if the given space is the default space of
	 *     the default context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : Space) : boolean
	
	/** Replies if the given identifier is the identifier of the default space of
	 * the default context.
	 *
	 * @param space the space to test.
	 * @return {@code true} if the given identifier is the identifier
	 *     of the default space of the default context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : SpaceID) : boolean

	/** Replies if the given identifier is the identifier of the default space of
	 * the default context.
	 *
	 * @param space the space to test.
	 * @return {@code true} if the given identifier is the identifier
	 *     of the default space of the default context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : UUID) : boolean

	/** Replies if the given event was emitted in the default space of
	 * the default context.
	 *
	 * @param event the event to test.
	 * @return {@code true} if the given event is emitted in the default
	 *     space of the default context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isInDefaultSpace(^event : Event) : boolean

	/** Replies if the given context is the default context.
	 *
	 * @param context the agent context to test.
	 * @return {@code true} if the given context is the default context.
	 *     Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isDefaultContext(context : AgentContext) : boolean
	
	/** Replies if the given identifier is the identifier of the default context.
	 *
	 * @param contextID the identifier of the context.
	 * @return {@code true} if the given identifier is the identifier
	 *     of the default context. Otherwise {@code false}.
	 * @since 0.2
	 */
	@Pure
	def isDefaultContext(contextID : UUID) : boolean

	/**
	 * Spawns a new Agent inside the default context of this agent.
	 * This action must automatically register the newly created agent
	 * within the default space of the context.
	 *
	 * @param agentType the type of the agent to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agent.
	 * @return the identifier of the spawned agent.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the cannot be spawn.
	 * @deprecated See the {@link Lifecycle} capacity.
	 */
	@Deprecated(since = "0.10", forRemoval = true)
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(agentType : Class<? extends Agent>, params : Object*) : UUID fires AgentSpawned, AgentSpawnFailure

}

/**
 * Gives access to the logging mechanism associated to the agent.
 */
capacity Logging {

	/** Change the name used for logging.
	 *
	 * @param name the name used for logging.
	 */
	def setLoggingName(name : String)

	/** Print the given message at information logging level.
	 * <p>
	 * <strong>This function is deprecated.</strong> Please use
	 * {@link #info(Object,Object...)} in place of {@code println}.
	 *
	 * @param message the elements to display.
	 * @deprecated Use {@link #info(Object,Object...)}.
	 */
	@Deprecated(since = "0.10", forRemoval = true)
	def println(message : Object)
	
	/** Print the given message at error logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param exception the exception that is the cause of the error.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def error(message : Object, exception : Throwable=null, parameters : Object*)

	/** Print the given message at error logging level.
	 *
	 * @param messageProvider provides the error message.
	 * @since 0.7
	 */
	def error(messageProvider : Supplier<String>)
	
	/** Print the given message at warning logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param exception the exception that is the cause of the error.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def warning(message : Object, exception : Throwable=null, parameters : Object*)

	/** Print the given message at warning logging level.
	 *
	 * @param messageProvider provides the warning message.
	 * @since 0.7
	 */
	def warning(messageProvider : Supplier<String>)

	/** Print the given message at information logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def info(message : Object, parameters : Object*)

	/** Print the given message at information logging level.
	 *
	 * @param messageProvider provides the info message.
	 * @since 0.7
	 */
	def info(messageProvider : Supplier<String>)

	/** Print the given message at debug logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def debug(message : Object, parameters : Object*)

	/** Print the given message at debug logging level.
	 *
	 * @param messageProvider provides the debug message.
	 * @since 0.7
	 */
	def debug(messageProvider : Supplier<String>)

	/** Replies if the logging system is displaying the errors.
	 *
	 * @return {@code true} if the errors are logged,
	 *         {@code false} if not.
	 */
	@Pure
	def isErrorLogEnabled : boolean

	/** Replies if the logging system is displaying the warnings.
	 *
	 * @return {@code true} if the warnings are logged,
	 *         {@code false} if not.
	 */
	@Pure
	def isWarningLogEnabled : boolean

	/** Replies if the logging system is displaying the information messages.
	 *
	 * @return {@code true} if the information messages are logged,
	 *         {@code false} if not.
	 */
	@Pure
	def isInfoLogEnabled : boolean

	/** Replies if the logging system is displaying the debugging messages.
	 *
	 * @return {@code true} if the debugging messages are logged,
	 *         {@code false} if not.
	 */
	@Pure
	def isDebugLogEnabled : boolean

	/** Replies the logging level.
	 *
	 * @return {@code 0} for no logging, {@code 1} for error,
	 *         {@code 2} for warning, {@code 3} for info,
	 *         {@code 5} for debug.
	 */
	@Pure
	def getLogLevel : int

	/** Set the logging level.
	 *
	 * @param level {@code 0} or lower for no logging, {@code 1} for error,
	 *         {@code 2} for warning, {@code 3} for info,
	 *         {@code 4} or higher for debug.
	 */
	def setLogLevel(level : int)

	/** Replies the backend logger.
	 *
	 * @return the backend logger.
	 */
	@Pure
	def getLogger : Logger

}

/**
* Gives access to the time in the agent application.
* Time management is application-dependent. This capacity does not make any assumption
* on neither time evolution nor time refresh rate.
*/
capacity Time {

	/** Replies the current time.
	 *
	 * @param timeUnit if present, specifies the time unit of the value to reply. By default is it seconds. 
	 * @return the current time.
	 */
 	def getTime(timeUnit : TimeUnit = null) : double

	/** Replies the scaling factor between the agent time and the operating system time.
	 * <p>Consider time in the agent application. It may evolves at a different rate than
	 * the operating system time. The value that is replied by this function permits to
	 * determine the proportionally between the agent application time and the operating system time.
	 * A typical equation for representing this relation is: os time = OSTimeFactor * agent time.
	 *
	 * @return the factor between agent time and operating system time.
	 */
	def getOSTimeFactor : double

	/** Convert the given time from the time scale of this builtin capacity to the operating
	 * system time scale. It means that the "SRE" milliseconds are converted to
	 * operating system milliseconds.
	 *
	 * @param timeValue the value to convert.
	 * @return the number of milleseconds in the OS that correspond to the given number in the SRE.
	 * @since 0.9
	 */
	def toOSTime(timeValue : double) : double

	/** Convert the given time from the operating system time scale to the time scale of this
	 * builtin capacity. It means that the operating system milliseconds are converted to
	 * "SRE" milliseconds.
	 *
	 * @param timeValue the value to convert.
	 * @return the number of milleseconds in the SRE that correspond to the given number in the OS.
	 * @since 0.9
	 */
	def fromOSTime(timeValue : double) : double

	/** Convert the given duration from the time scale of this builtin capacity to the operating
	 * system time scale. It means that the "SRE" milliseconds are converted to
	 * operating system milliseconds.
	 *
	 * @param timeDuration the value to convert.
	 * @return the number of milleseconds in the OS that correspond to the given number in the SRE.
	 * @since 0.9
	 */
	def toOSDuration(timeDuration : double) : double

	/** Convert the given duration from the operating system time scale to the time scale of this
	 * builtin capacity. It means that the operating system milliseconds are converted to
	 * "SRE" milliseconds.
	 *
	 * @param timeDuration the value to convert.
	 * @return the number of milleseconds in the SRE that correspond to the given number in the OS.
	 * @since 0.9
	 */
	def fromOSDuration(timeDuration : double) : double

}
