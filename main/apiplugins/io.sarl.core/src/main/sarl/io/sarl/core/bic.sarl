/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2021 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.core

import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import io.sarl.lang.core.Behavior
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventListener
import io.sarl.lang.core.EventSpace
import io.sarl.lang.core.Scope
import io.sarl.lang.core.Space
import io.sarl.lang.core.SpaceID
import io.sarl.lang.util.ConcurrentCollection
import io.sarl.lang.util.ConcurrentSet
import java.text.MessageFormat
import java.util.UUID
import java.util.concurrent.TimeUnit
import java.util.function.Supplier
import java.util.logging.Logger
import io.sarl.lang.annotation.SarlAsynchronousExecution

/**
 * Provides functions for accessing and managing the external contexts of an agent.
 */	 
capacity ExternalContextAccess {

	/**
	 * Replies all contexts this agent is a member of, including the default context.
	 *
	 * @return the list of the known agent contexts.
	 */	 
	@Pure
	def getAllContexts : ConcurrentCollection<AgentContext>

	/**
	 * Replies the AgentContext for the given ID.
	 * The agent must have joined the context before calling this action or use its parentContextID
	 *
	 * @param contextID the ID of the context to get.
	 * @return the agent context instance.
	 * @throws UnknownContextException if the context specified context is not known by the agent.
	 * @see Agent#getParentID
	 * @see #join
	 */
	@Pure
	def getContext(contextID : UUID): AgentContext

	/**
	 * Replies the AgentContext that is the root of all the contexts.
	 * Usually, the Universe context is managed by the SARL run-time environment.
	 * The agent may be a member of this context, or not.
	 *
	 * @return the context that is at the root of all the contexts.
	 * @since 0.7
	 */
	@Pure
	def getUniverseContext(): AgentContext

    /**
	 * Joins a new parent context (a new super holon).
	 * <p>
	 * The agent will be involved in the context with the ID given by <var>contextID</var>.
	 * The parameter <var>expectedDefaultSpaceID</var> is only used to check if
	 * the caller of this function knows the ID of the default space in the context to
	 * be involved in. Note that the context must already exists, and the default space
	 * inside this context must have the same ID as <var>expectedDefaultSpaceID</var>.
	 * If the given <var>expectedDefaultSpaceID</var> does not match the ID of the
	 * default space in the context <var>contextID</var>, then the access to the context
	 * is forbidden.
	 *
	 * <p>This actions registers the agent in the default Space of the context with the
	 * ID <var>contextID</var>.
	 *
	 * <p>This function replies {@code false} if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive;</li>
	 * <li>the given context identifier does not corresponds to a known context;</li>
	 * <li>the given space identifier is not the one of the context's default space;</li>
	 * <li>the given context identifier corresponds to a context in which the agent is already member.</li>
	 * </ul>
	 *
	 * @param contextID the identifier of the context to join.
	 * @param expectedDefaultSpaceID the known identifier of the default space in the agent context with the given identifier.
	 * @return the joined context. {@code null} if the context cannot be joined.
	 * @fires ContextJoined in its inner Context default space (Behaviors#wake).
	 * @fires MemberJoined in its parent Context default Space
	 * @since 0.12 for the returned context.
	 */
	def join(contextID : UUID, expectedDefaultSpaceID : UUID) : AgentContext fires ContextJoined, MemberJoined

	/**
	 * Leaves the parent's context.
	 *
	 * <p>Because an agent must be always into a context, this function fails (and replies {@code false}) when
	 * the context to be leaved is the current default context of the agent, and there is no other context or
	 * more than 1 other context that could be elected as the new default context.
	 *
	 * <p>This function replies {@code false} if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive;</li>
	 * <li>the given context identifier does not corresponds to a known context;</li>
	 * <li>the given context identifier corresponds to a context in which the agent is not member.</li>
	 * <li>the given context identifier corresponds to a known external context, but there is no other
	 * context to be elected as the new default context for the agent.</li>
	 * </ul>
	 *
	 * @param contextID the identifier of the context to leave.
	 * @return {@code true} if the agent has leaved the context. {@code false} if one of the conditions described in
	 *     the function's comment evaluates to true.
	 * @fires ContextLeft in its inner Context default space (Behaviors#wake).
	 * @fires MemberLeft in its parent Context default Space 
	 */
	def leave(contextID : UUID) : boolean fires ContextLeft, MemberLeft

	/** Replies if the given event was emitted in the given space.
	 *
	 * @param event the event to test.
	 * @param space the space in which the event may be.
	 * @return <code>true</code> if the given event was emitted in the
	 *     given space. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, ^space : Space) : boolean

	/** Replies if the given event was emitted in the space with
	 * the given identifier..
	 *
	 * @param event the event to test.
	 * @param spaceID the identifier of the space in which the event may be.
	 * @return <code>true</code> if the given event was emitted in the
	 *     space with the given identifier. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, spaceID : SpaceID) : boolean

	/** Replies if the given event was emitted in the space with
	 * the given identifier..
	 *
	 * @param event the event to test.
	 * @param spaceID the identifier of the space in which the event may be.
	 * @return <code>true</code> if the given event was emitted in the
	 *     space with the given identifier. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInSpace(^event : Event, spaceID : UUID) : boolean

	/**
	 * Emits a given event with the provided scope in the given space.
	 * Equivalent to <code>space.emit(getID,event,scope)</code>
	 *
	 * @param space the space in which the event should be fired.
	 * @param event the event to emit.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events. If {@code null}, all the agents in the space will receive the event.
	 * @since 0.6
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emit(^space : EventSpace, ^event : Event, scope : Scope<Address> = null)

}

/**
 * Provides functions for accessing and managing the internal contexts of an agent.
 */	 
capacity InnerContextAccess {

	/** Replies the inner context.
	 *
	 * @return the instance of the internal agent context.
	 */
	@Pure
	def getInnerContext : AgentContext
	
	/** Replies the inner context.
	 *
	 * @return the instanceof the internal agent context.
	 * @since 0.12
	 */
	@Pure
	def getInnerDefaultSpace : EventSpace

	/** Replies if the calling agent has other agents
	 * as members of its inner context.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context.
	 *
	 * @return <code>true</code> if the current agent has other agents as member of its internal context; otherwise <code>false</code>
	 */
	@Pure
	def hasMemberAgent : boolean
	
	/** Replies the number of agents that are members
	 * of the inner context of the calling agent.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context.
	 *
	 * <p>The replied number includes the current agent. Indeed, the current agent is member of its internal context with the role of super-holon.
	 *
	 * @return the number of members in the internal context of the current agent.
	 */
	@Pure
	def getMemberAgentCount : int

	/**
	 * Replies all the member agents in the inner context.
	 * A member agent is an agent which is not the
	 * calling agent, and is a member of at least
	 * one space of the inner context. 
	 *
	 * @return the identifiers of the members of the internal context of the current agent.
	 */	 
	@Pure
	def getMemberAgents : ConcurrentSet<UUID>

	/** Replies if the given space is the default space of the inner context.
	 *
	 * @param space the space to test.
	 * @return <code>true</code> if the given space is the default space of
	 *     the inner context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(^space : Space) : boolean

	/** Replies if the given identifier is the identifier of the
	 * default space of the inner context.
	 *
	 * @param spaceID the identifier to test.
	 * @return <code>true</code> if the given identifier is the identifier
	 *     of the default space of the inner context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(spaceID : SpaceID) : boolean

	/** Replies if the given identifier is the identifier of the
	 * default space of the inner context.
	 *
	 * @param spaceID the identifier to test.
	 * @return <code>true</code> if the given identifier is the identifier
	 *     of the default space of the inner context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInnerDefaultSpace(spaceID : UUID) : boolean

	/** Replies if the given event was emitted in the default space
	 * of the inner context.
	 *
	 * @param event the event to test.
	 * @return <code>true</code> if the given event was emitted
	 *     in the default space of the inner context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInInnerDefaultSpace(^event : Event) : boolean

}

/**
 * Agent behaviors management.
 */
capacity Behaviors {

	/** Replies <code>true</code> if at least a behavior is registered.
	 *
	 * <p>A registered behavior is not necessary running. It may wait for events.
	 *
	 * @return <code>true</code> if a behavior is registered; otherwise <code>false</code>.
	 * @since 0.5
	 */
	def hasRegisteredBehavior : boolean

	/** Replies the registered behaviors.
	 *
	 * <p>A registered behavior is not necessary running. It may wait for events.
	 *
	 * @return the unmodifiable collection of the registered behavior.
	 * @since 0.5
	 */
	def getRegisteredBehaviors : ConcurrentCollection<Behavior>

	/**
	 * Register a Behavior for the owner agent.
	 * The new Behavior will react to all declared events received by the agent.
	 *
	 * <p>If the filter is provided, it will be used for determining if the given behavior accepts a specific event.
	 * If the filter function replies {@code true} for a specific event as argument, the event is fired in the
	 * behavior context. If the filter function replies {@code false}, the event is not fired in the behavior context. 
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param attitude the behavior to add to the agent.
	 * @param filter the filter that enables to indicates if an event is accepted by a behavior.
	 * @param initializationParameters the set of parameters to pass to the behavior within the {@code Initialize} event.
	 * @return the given behavior.
	 * @since 0.5 for the {@code filter} parameter.
	 */
	def registerBehavior(attitude : Behavior, filter : (Event) => boolean = null, initializationParameters : Object*) : Behavior
	
	/**
	 * Unregisters a behavior for the owner agent.
	 *
	 * @param attitude the behavior to remove to the agent.
	 * @return the given behavior.
	 */
	def unregisterBehavior(attitude : Behavior) : Behavior
	
	/**
	 * Wake the agent's behaviors reacting to the Event evt.
	 *
	 * <p>Note that the scope parameter could be used only for filtering the agents (the current receiving agent)
	 * in order to determine the ones that will receive the event.
	 * The behaviors of the current agent (registered with
	 * {@link #registerBehavior(Behavior, Function1, Object[])}
	 * will always
	 * receive the event if the current agent is not discarded. Because the behaviors have no associated address,
	 * they cannot be filtered individually.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(^event : Event, scope : Scope<Address> = null)
	
	/**
	 * Wake a specific agent's behavior reacting to the Event evt.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param behavior the agent's behavior to wake up.
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(^behavior : Behavior, ^event : Event)

	/**
	 * Wake a set of specific agent's behaviors reacting to the Event evt.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param behaviors the agent's behaviors to wake up.
	 * @param event the event to emit to the agent's behaviors and in the internal context.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def wake(behaviors : Iterable<Behavior>, ^event : Event)

	/**
	 * Replies the interface to dispatch an event to agent's Behaviors.
	 *
	 * @return the event listener.
	 */
	@Pure
	def asEventListener : EventListener

}

/**
 * Lifecycle related actions.
 */
capacity Lifecycle {

	/**
	 * Spawns a new Agent inside the default context of this agent.
	 * This action must automatically register the newly created agent
	 * within the default space of the context.
	 *
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentType the type of the agent to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agent.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(agentType : Class<? extends Agent>, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a group of agents inside the default context of this agent.
	 * This action must automatically register the newly created agents
	 * within the default space of the context.
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agents
	 * are initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param nbAgents the number of agents to spawn.
	 * @param agentType the type of the agents to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agents. All the agents
	 *     will receive the same initialization parameters.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(nbAgents : int, agentType : Class<? extends Agent>, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param context the context in which the agent must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContext(agentClass : Class <? extends Agent>, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure
	
	/**
	 * Spawns a group of agents in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agents
	 * are initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param nbAgents the number of agents to spawn.
	 * @param agentClass the type of the agents to spawn.
	 * @param context the context in which the agents must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agents. All the agents
	 *     will receive the same initialization parameters.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.5
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContext(nbAgents : int, agentClass : Class <? extends Agent>, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the given context.
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param agentID the identifier of the spawned agent.
	 * @param context the context in which the agent must be spawned.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnInContextWithID(agentClass : Class <? extends Agent>, agentID : UUID, context : AgentContext, params : Object*) fires AgentSpawned, AgentSpawnFailure

	/**
	 * Spawns a new member agent in the parent's context (parentID).
	 * 
	 * <p>Caution: when this function returns, there is no warranty that the spawned agent
	 * is initialized at the time of the return.
	 * Indeed, agent spawning is done in parallel to the calling thread.
	 * This parallel task for spawning is not considered as an agent task, i.e. it cannot
	 * be stopped or cancelled by the spawning agent, or if this agent is killed.
	 * 
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param agentClass the type of the agent to spawn.
	 * @param agentID the identifier of the spawned agent.
	 * @param params the arguments to pass to the initialization event that will be sent to the spawned agent.
	 * @fires AgentSpawned inside the default context of the parent. The source of the event is this agent.
	 * @fires AgentSpawnFailure if the agent cannot be spawned.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawnWithID(agentClass : Class <? extends Agent>, agentID : UUID, params : Object*) fires AgentSpawned, AgentSpawnFailure

    /**
	 * Kills this agent. 
	 *
	 * <p>This action must automatically unregister this agent from the default context 
	 * and therefore all its spaces including the DefaultSpace.
	 * If this is a composable agent, it must not have any members before calling this action. 
	 * Otherwise a RuntimeException will be thrown.  
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param terminationCause indicates the cause of the termination of the agent.
	 *      If this argument is {@code null}, the agent terminates without specific cause.
	 * @fires AgentKilled in DefaultSpace of all Contexts to which this agent belongs
	 * @fires Destroy inside the agent
	 * @fires AgentKillFailure inside the agent
	 * @since 0.12
	 */
	def killMe(terminationCause : Object = null) fires AgentKilled, Destroy, AgentKillFailure
}


/**
 * Schedules actions in time.
 */
capacity Schedules {

	/**
	 * Replies the names of the active tasks.
	 *
	 * @return the names of the active tasks.
	 * @since 0.5
	 */
	def getActiveTasks : ConcurrentSet<String>
	
	/**
	 * Schedule a given task to be executed after the specified delay.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name <code>it</code> by default.
	 *
	 * <p>The given delay is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task that will run the given closure. If {@code null}, a new task is created.
	 * @param delay time in milliseconds to delay the procedure execution.
	 * @param procedure the closure to execute.
	 * @return the generated task.
	 */
	def in(task : AgentTask = null, delay : long, procedure : (Agent) => void) : AgentTask

	/**
	 * Create a named task that can be retrieved and schedule later.
	 * If a task with the specified name already exists, this task is returned.
	 *
	 * <p>If this function is invoked from a {@code Behavior}, the created task will be associated
	 * to the behavior instance. It means that the task will be automatically canceled when the behavior
	 * instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param name the name of the task. If {@code null} or empty, a random name will be given to the task.
	 * @return the task instance, or {@code null} if one of the conditions in the function's comment
	 *      evaluates to true.
	 */
	def task(name : String) : AgentTask

	/**
	 * Change the name of the given task.
	 *
	 * <p>This function should not be directly invoked from a regular SARL code.
	 * It is provided for enabling a SRE to change the name of a task.
	 *
	 * @param task the task to change.
	 * @param name the new name of the task.
	 * @since 0.7
	 */
	def setName(task : AgentTask, name : String)

	/**
	 * Attempts to cancel execution of this task.  This attempt will
	 * fail if the task has already completed, has already been canceled,
	 * or could not be canceled for some other reason. If successful,
	 * and this task has not started when <code>cancel</code> is called,
	 * this task should never run.  If the task has already started,
	 * then the <code>mayInterruptIfRunning</code> parameter determines
	 * whether the thread executing this task should be interrupted in
	 * an attempt to stop the task.
	 *
	 * @param task the task to cancel.
	 * @param mayInterruptIfRunning <code>true</code> if the thread executing this
	 *     task should be interrupted; otherwise, in-progress tasks are allowed
	 *     to complete
	 * @return <code>false</code> if the task could not be canceled,
	 *     typically because it has already completed normally;
	 *     <code>true</code> otherwise
	 */
	def cancel(task : AgentTask, mayInterruptIfRunning : boolean = true) : boolean

	/**
	 * Replies if the given task was canceled.
	 *
	 * @param task the task.
	 * @return <code>true</code> if the task was canceled with {@link #cancel(AgentTask,boolean)}
	 *     or {@link #cancel(AgentTask)}; <code>false</code> otherwise.
	 * @since 0.5
	 */
	def isCanceled(task : AgentTask) : boolean

	/**
	 * Schedule a periodic execution of the given task.
	 *
	 * <p>If the duration of the task is greater to the given period length, then
	 * multiple task's instances will be run in parallel, in opposite to the
	 * {@code atFixedDelay()} function.
	 * For example, consider the following code:
	 * <pre><code>
	 * every(500) [ sleep(2000) ]
	 * </code></pre>
	 * At a given time, 4 instances (A, B, C, D) of the task may be run in parallel:
	 * <pre><code>
	 * t=0   0500   1000   1500   2000   2500   3000   3500   4000   4500
	 *   |    |      |      |      |      |      |      |      |      |
	 *   [-A-----------------------]
	 *        [-B-------------------------]
	 *               [-C-------------------------]
	 *                      [-D-------------------------]
	 *                             [-E-------------------------]
	 *                                    [-F-------------------------]
	 * </code></pre>
	 * For executing a task with a fixed delay between the runs, and not at a fixed rate,
	 * you should use the {@code atFixedDelay()} function.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name <code>it</code> by default.
	 *
	 * <p>The given period is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param period the number of milliseconds between two launches of the given procedure.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 */
	def every(task : AgentTask = null, period : long, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a single-execution task.
	 *
	 * <p>If the duration of the task is greater to the given delay length, then
	 * no multiple task's instance are run in parallel, in opposite to the
	 * {@code every()} function.
	 * For example, consider the following code:
	 * <pre><code>
	 * atFixedDelay(500) [ sleep(2000) ]
	 * </code></pre>
	 * At a given time, 3 instances (A, B, C) of the task are run in sequence, and
	 * each run is separated by 500 milliseconds:
	 * <pre><code>
	 * t=0   0500   1000   1500   2000   2500   3000   3500   4000   4500   5000
	 *   |    |      |      |      |      |      |      |      |      |      |
	 *   [-A-----------------------]
	 *                                    [-B-------------------------]
	 *                                                                       [-C-------------------------]
	 * </code></pre>
	 * For executing a task with a fixed rate, and not with a fixed delay between the task runs,
	 * you should use the {@code every()} function.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name <code>it</code> by default.
	 *
	 * <p>The given delay is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>It is recommended that the SARL run-time environment, which is providing the implementation
	 * of this function to provide an efficient implementation in the case the argument
	 * {@code delay} is equal to zero. Indeed, if the {@code delay} is equal to zero, the task
	 * should be run in an infinite loop until it is canceled, or the owning agent is killed.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param delay the delay in milliseconds.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 * @since 0.5
	 */
	def atFixedDelay(task : AgentTask = null, delay : long, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a single-execution task.
	 *
	 * <p>This function is the easy to use version and efficient implementation of the code
	 * {@code in(0) [statements]}.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name <code>it</code> by default.
	 *
	 * <p>This function is supposed to execute the given procedure, even if the agent is not alive.
	 *
	 * @param task the task to associate to the procedure. If {@code null} a new task is created.
	 * @param procedure the procedure to launch. The parameter of the procedure is the agent.
	 * @return the given task.
	 * @since 0.5
	 */
	def execute(task : AgentTask = null, procedure : (Agent) => void ) : AgentTask

	/**
	 * Schedule a given task to be executed at the given time.
	 *
	 * <p>If the given time is passed, according to {@link Time} then the task is not executed.
	 *
	 * <p>The given procedure takes one parameter: the agent associated to the task. It is name <code>it</code> by default.
	 *
	 * <p>The given time is expressed in milliseconds according to the time scale of the SRE.
	 * It means that the given number of milliseconds may be not real milliseconds, depending
	 * on the definition of the builtin capacity {@link Time}.
	 *
	 * <p>If this function is invoked from a {@code Behavior} and there is no provided task,
	 * the created task will be associated to the behavior instance. It means that the task will
	 * be automatically canceled when the behavior instance is unregistered from the the owning agent.
	 *
	 * <p>This function does nothing if one of the following conditions evaluates to true:
	 * <ul>
	 * <li>the agent is not alive.</li>
	 * </ul>
	 *
	 * @param task the task that will run the given closure. If {@code null}, a new task is created.
	 * @param time the time in milliseconds at which to start the procedure execution.
	 * @param procedure the closure to execute.
	 * @return the task is given, or a new task if the procedure is schedule, or
	 *     {@code null} if the procedure is not scheduled.
	 * @since 0.9
	 */
	def at(task : AgentTask = null, time : long, procedure : (Agent) => void) : AgentTask

}


/**
 * Gives access to the DefaultContext of the agent and common actions on its default space.
 * Defines a set of commonly accessed action performed on the Default Space 
 * of the Default Context of the agent.
 */
capacity DefaultContextInteractions {

	/**
	 * Returns the Default context fo the agent.
	 *
	 * @return the default context.
	 */
	@Pure
	def getDefaultContext : AgentContext
	
	/**
	 * Returns the Default Space of the Default Context.
	 * Equivalent to <code>defaultContext.defaultSpace</code>.
	 *
	 * @return the default event space.
	 */
	@Pure
	def getDefaultSpace : EventSpace
	
	/**
	 * Return the Address of the agent in the Default Space of the Default Context.
	 * Equivalent to <code>defaultContext.defaultSpace.getAddress(this.ID)</code>
	 *
	 * @return the address of the agent in the default space.
	 */
	@Pure
	def getDefaultAddress : Address

	/**
	 * Emits a given event with the provided scope in the DefaultSpace of the DefaultContext.
	 * Equivalent to <code>defaultContext.defaultSpace.emit(e,scope)</code>
	 *
	 * @param event the event to emit.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events. If {@code null}, all the agents in the space will receive the event.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emit(^event : Event, scope : Scope<Address> = null)

	/**
	 * Replies the identifier of the default parent.
	 *
	 * <p>The default parent agent has the same identifier as the default context.
	 *
	 * @return the identifier of the default parent of the current agent.
	 * @since 0.12
	 */
	def getDefaultParentID : UUID

	/**
	 * Replies the event scope that corresponds to the default parent.
	 *
	 * @return the identifier of the default parent of the current agent.
	 * @since 0.12
	 */
	def getDefaultParentScope : Scope<Address>

	/**
	 * Emits or forward the given event to the parent agent into the default context of the calling agent.
	 *
	 * @param event the event to emit.
	 * @param scope the definition of the scope that will be used for selected the receivers of the events. If {@code null}, all the agents in the space will receive the event.
	 * @since 0.12
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def emitToParent(^event : Event)

	/**
	 * Inverse signature of send. Useful to send events using the agent's UUID.
	 *
	 * @param receiver the identifier of the expected receiver.
	 * @param event the event to emit.
	 * @since 0.4
	 * @deprecated since 0.11, see {@link #emit(Event,Scope)} 
	 */
	@Deprecated
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def willReceive(receiver : UUID, ^event : Event)

	/** Replies if the given space is the default space of the default context.
	 *
	 * @param space the space to test.
	 * @return <code>true</code> if the given space is the default space of
	 *     the default context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : Space) : boolean
	
	/** Replies if the given identifier is the identifier of the default space of
	 * the default context.
	 *
	 * @param space the space to test.
	 * @return <code>true</code> if the given identifier is the identifier
	 *     of the default space of the default context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : SpaceID) : boolean

	/** Replies if the given identifier is the identifier of the default space of
	 * the default context.
	 *
	 * @param space the space to test.
	 * @return <code>true</code> if the given identifier is the identifier
	 *     of the default space of the default context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isDefaultSpace(^space : UUID) : boolean

	/** Replies if the given event was emitted in the default space of
	 * the default context.
	 *
	 * @param event the event to test.
	 * @return <code>true</code> if the given event is emitted in the default
	 *     space of the default context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isInDefaultSpace(^event : Event) : boolean

	/** Replies if the given context is the default context.
	 *
	 * @param context the agent context to test.
	 * @return <code>true</code> if the given context is the default context.
	 *     Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isDefaultContext(context : AgentContext) : boolean
	
	/** Replies if the given identifier is the identifier of the default context.
	 *
	 * @param contextID the identifier of the context.
	 * @return <code>true</code> if the given identifier is the identifier
	 *     of the default context. Otherwise <code>false</code>.
	 * @since 0.2
	 */
	@Pure
	def isDefaultContext(contextID : UUID) : boolean

	/**
	 * Spawns a new Agent inside the default context of this agent.
	 * This action must automatically register the newly created agent
	 * within the default space of the context.
	 *
	 * @param agentType the type of the agent to spawn.
	 * @param params the arguments to pass in the initialization event to the spawned agent.
	 * @return the identifier of the spawned agent.
	 * @fires AgentSpawned in DefaultSpace
	 * @fires AgentSpawnFailure if the cannot be spawn.
	 * @deprecated See the {@link Lifecycle} capacity.
	 */
	@Deprecated
	@SuppressWarnings("use_reserved_sarl_annotation")
	@SarlAsynchronousExecution
	def spawn(agentType : Class<? extends Agent>, params : Object*) : UUID fires AgentSpawned, AgentSpawnFailure

}

/**
 * Gives access to the logging mechanism associated to the agent.
 */
capacity Logging {

	/** Change the name used for logging.
	 *
	 * @param name the name used for logging.
	 */
	def setLoggingName(name : String)

	/** Print the given message at information logging level.
	 * <p>
	 * <strong>This function is deprecated.</strong> Please use
	 * {@link #info(Object,Object...)} in place of <code>println</code>.
	 *
	 * @param message the elements to display.
	 * @deprecated Use {@link #info(Object,Object...)}.
	 */
	@Deprecated
	def println(message : Object)
	
	/** Print the given message at error logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param exception the exception that is the cause of the error.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def error(message : Object, exception : Throwable=null, parameters : Object*)

	/** Print the given message at error logging level.
	 *
	 * @param messageProvider provides the error message.
	 * @since 0.7
	 */
	def error(messageProvider : Supplier<String>)
	
	/** Print the given message at warning logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param exception the exception that is the cause of the error.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def warning(message : Object, exception : Throwable=null, parameters : Object*)

	/** Print the given message at warning logging level.
	 *
	 * @param messageProvider provides the warning message.
	 * @since 0.7
	 */
	def warning(messageProvider : Supplier<String>)

	/** Print the given message at information logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def info(message : Object, parameters : Object*)

	/** Print the given message at information logging level.
	 *
	 * @param messageProvider provides the info message.
	 * @since 0.7
	 */
	def info(messageProvider : Supplier<String>)

	/** Print the given message at debug logging level.
	 *
	 * @param message the elements to display. The format of the message must follow {@link MessageFormat}.
	 * @param parameters the values to dynamically insert into the message.
	 */
	def debug(message : Object, parameters : Object*)

	/** Print the given message at debug logging level.
	 *
	 * @param messageProvider provides the debug message.
	 * @since 0.7
	 */
	def debug(messageProvider : Supplier<String>)

	/** Replies if the logging system is displaying the errors.
	 *
	 * @return <code>true</code> if the errors are logged,
	 *         <code>false</code> if not.
	 */
	@Pure
	def isErrorLogEnabled : boolean

	/** Replies if the logging system is displaying the warnings.
	 *
	 * @return <code>true</code> if the warnings are logged,
	 *         <code>false</code> if not.
	 */
	@Pure
	def isWarningLogEnabled : boolean

	/** Replies if the logging system is displaying the information messages.
	 *
	 * @return <code>true</code> if the information messages are logged,
	 *         <code>false</code> if not.
	 */
	@Pure
	def isInfoLogEnabled : boolean

	/** Replies if the logging system is displaying the debugging messages.
	 *
	 * @return <code>true</code> if the debugging messages are logged,
	 *         <code>false</code> if not.
	 */
	@Pure
	def isDebugLogEnabled : boolean

	/** Replies the logging level.
	 *
	 * @return <code>0</code> for no logging, <code>1</code> for error,
	 *         <code>2</code> for warning, <code>3</code> for info,
	 *         <code>5</code> for debug.
	 */
	@Pure
	def getLogLevel : int

	/** Set the logging level.
	 *
	 * @param level <code>0</code> or lower for no logging, <code>1</code> for error,
	 *         <code>2</code> for warning, <code>3</code> for info,
	 *         <code>4</code> or higher for debug.
	 */
	def setLogLevel(level : int)

	/** Replies the backend logger.
	 *
	 * @return the backend logger.
	 */
	@Pure
	def getLogger : Logger

}

/**
* Gives access to the time in the agent application.
* Time management is application-dependent. This capacity does not make any assumption
* on neither time evolution nor time refresh rate.
*/
capacity Time {

	/** Replies the current time.
	 *
	 * @param timeUnit if present, specifies the time unit of the value to reply. By default is it seconds. 
	 * @return the current time.
	 */
 	def getTime(timeUnit : TimeUnit = null) : double

	/** Replies the scaling factor between the agent time and the operating system time.
	 * <p>Consider time in the agent application. It may evolves at a different rate than
	 * the operating system time. The value that is replied by this function permits to
	 * determine the proportionally between the agent application time and the operating system time.
	 * A typical equation for representing this relation is: os time = OSTimeFactor * agent time.
	 *
	 * @return the factor between agent time and operating system time.
	 */
	def getOSTimeFactor : double

	/** Convert the given time from the time scale of this builtin capacity to the operating
	 * system time scale. It means that the "SRE" milliseconds are converted to
	 * operating system milliseconds.
	 *
	 * @param timeValue the value to convert.
	 * @return the number of milleseconds in the OS that correspond to the given number in the SRE.
	 * @since 0.9
	 */
	def toOSTime(timeValue : double) : double

	/** Convert the given time from the operating system time scale to the time scale of this
	 * builtin capacity. It means that the operating system milliseconds are converted to
	 * "SRE" milliseconds.
	 *
	 * @param timeValue the value to convert.
	 * @return the number of milleseconds in the SRE that correspond to the given number in the OS.
	 * @since 0.9
	 */
	def fromOSTime(timeValue : double) : double

	/** Convert the given duration from the time scale of this builtin capacity to the operating
	 * system time scale. It means that the "SRE" milliseconds are converted to
	 * operating system milliseconds.
	 *
	 * @param timeDuration the value to convert.
	 * @return the number of milleseconds in the OS that correspond to the given number in the SRE.
	 * @since 0.9
	 */
	def toOSDuration(timeDuration : double) : double

	/** Convert the given duration from the operating system time scale to the time scale of this
	 * builtin capacity. It means that the operating system milliseconds are converted to
	 * "SRE" milliseconds.
	 *
	 * @param timeDuration the value to convert.
	 * @return the number of milleseconds in the SRE that correspond to the given number in the OS.
	 * @since 0.9
	 */
	def fromOSDuration(timeDuration : double) : double

}
