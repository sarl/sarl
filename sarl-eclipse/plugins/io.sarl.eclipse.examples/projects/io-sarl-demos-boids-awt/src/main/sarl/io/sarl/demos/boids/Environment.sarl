/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-2025 SARL.io, the Original Authors and Main Authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.demos.boids

import io.sarl.api.core.DefaultContextInteractions
import io.sarl.api.core.Initialize
import io.sarl.api.core.Lifecycle
import io.sarl.api.core.Logging
import io.sarl.api.core.Schedules
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentSkipListSet
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.eclipse.xtend.lib.annotations.Accessors

/** 
 * The environmental agent in charge of collecting boids influences and computing the new state of the virtual world
 * @author $Author: ngaud$
 * @author $Author: sgalland$
 */
agent Environment {

	uses Logging, DefaultContextInteractions, Schedules, Lifecycle

	@Accessors
	var width : int

	@Accessors
	var height : int

	@Accessors
	var boids : ConcurrentHashMap<UUID, PerceivedBoidBody>

	// Set of boids ID who has sent their influence in the current time step
	@Accessors
	var influences : ConcurrentSkipListSet<UUID>

	on Initialize {
		loggingName = "Environment"
		// Environment init parameters : An Integer the grid's height, An integer the grid's width
		if (occurrence.parameters.size > 1) {
			val param0 = occurrence.parameters.get(0)
			if (param0 instanceof Number) {
				height = param0.intValue
			}

			val param1 = occurrence.parameters.get(1)
			if (param1 instanceof Number) {
				width = param1.intValue
			}
			boids = null
			influences = new ConcurrentSkipListSet

		}
	}

	on Start {
		this.boids = occurrence.perceivedAgentBody
		new GuiRepaint(boids).emit
		new Perception(boids).emit
	}

	@SuppressWarnings("constant_condition")
	on Action {
		synchronized (boids) {
			synchronized (influences) { // Two very important "synchronized" blocks that prevent the simulation from thread interblocking
				if (boids.containsKey(occurrence.source.ID)) {
					this.influences.add(occurrence.source.ID)
					applyForce(occurrence.influence, boids.get(occurrence.source.ID))
				}

				if (this.influences.size == this.boids.size) {
					// All boids have sent their influences
					in(Settings::pause) [
						new GuiRepaint(boids).emit[it.ID == BoidsSimulation.id]
						new Perception(boids).emit
						if (Settings::isLogActivated) {
							info("New Simulation Step.")
						}
					]
					this.influences.clear
				}
			}
		}
	}

	on Die {
		killMe
	}

	def applyForce(force : Vector2d, b : PerceivedBoidBody) {
		// limiting/clamping the applied force
		if (force.length > b.group.maxForce) {
			force.length = b.group.maxForce
		}

		// contribution of the mass.
		// force * (1 / b.getGroupe().masse);
		// updating acceleration and speed.
		var acceleration = b.acceleration
		acceleration.set(force)
		var vitesse = b.vitesse
		vitesse += acceleration

		// updating speed
		if (vitesse.length > b.group.maxSpeed) {
			vitesse.length = b.group.maxSpeed
		}

		// updating the position
		var position = b.position
		position += vitesse

		var bb = boids.get(b.owner)
		bb.acceleration = acceleration
		bb.vitesse = vitesse
		bb.position = position

		// we adjust it according to the dimensions of the World.
		b.clampToWorld
	}

	/** 
	 * The world is circular, this function clamps coordinates to stay within the frame
	 */
	def clampToWorld(b : PerceivedBoidBody) {
		var posX = b.position.x
		var posY = b.position.y

		if (posX > width / 2) {
			posX -= width
		}
		if (posX < ( -1 * width / 2 )) {
			posX += width
		}
		if (posY > height / 2) {
			posY -= height
		}
		if (posY < ( -1 * height / 2 )) {
			posY += height
		}

		boids.get(b.owner).position = new Vector2d(posX, posY)
	}

}
